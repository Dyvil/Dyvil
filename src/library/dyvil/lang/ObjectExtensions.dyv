package dyvil.lang

import dyvilx.lang.model.`type`.Type

import const dyvil.reflect.Opcodes._

public final class ObjectExtensions
{
	private init() { }

	// Class and Type conversions and utilities

	@Intrinsic([ LOAD_0 ])
	public static T cast<T>(any value) = value as T

	@Intrinsic([ LOAD_0 ])
	public static T convert<T>(T value) = value

	public static Class<T> classOf<@Reified(Reified.Type.ANY_CLASS) T>(T value) = class T

	public static Type<T> typeOf<@Reified(Reified.Type.TYPE) T>(T value) = type T

	// Useful globals

	public static inline R run<R>(-> R f) = f()

	public static infix inline R run<T, R>(T self, T.() -> R f) = f(self)

	public static infix inline T use<T>(T self, T.() -> void f) { f self; self }

	public static inline R with<T, R>(T receiver, T -> R f) = f(receiver)

	// Object Extensions

	// Structural Equality (equals)
	@Intrinsic([ LOAD_0, LOAD_1, INVOKEVIRTUAL, 0, 1, 2 ]
	  strings: [ "java/lang/Object", "equals", "(Ljava/lang/Object;)Z" ])
	public infix func ==(Object lhs, Object! rhs): boolean = lhs.equals(rhs)

	// Reference Equality
	@Intrinsic([ LOAD_0, LOAD_1, ACMPEQ ])
	public infix func ===(Object! lhs, Object! rhs): boolean = lhs === rhs

	// Structural Inequality (!equals)
	@Intrinsic([ LOAD_0, LOAD_1, INVOKEVIRTUAL, 0, 1, 2, BNOT ]
	  strings: [ "java/lang/Object", "equals", "(Ljava/lang/Object;)Z" ])
	public infix func !=(Object lhs, Object! rhs): boolean = !lhs.equals(rhs)

	// Reference Inequality
	@Intrinsic([ LOAD_0, LOAD_1, ACMPNE ])
	public infix func !==(Object! lhs, Object! rhs): boolean = lhs !== rhs

	// Comparable

	public infix inline func < <T>(Comparable<T> lhs, T rhs): boolean = lhs.compareTo(rhs) < 0

	public infix inline func <= <T>(Comparable<T> lhs, T rhs): boolean = lhs.compareTo(rhs) <= 0

	public infix inline func > <T>(Comparable<T> lhs, T rhs): boolean = lhs.compareTo(rhs) > 0

	public infix inline func >= <T>(Comparable<T> lhs, T rhs): boolean = lhs.compareTo(rhs) >= 0
}
