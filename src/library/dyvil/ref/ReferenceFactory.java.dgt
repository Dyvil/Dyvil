package dyvil.ref;

import dyvil.ref.array.*;
import dyvil.ref.unsafe.*;
import dyvil.reflect.ReflectUtils;
import dyvil.runtime.reference.PropertyReferenceMetafactory;

import java.lang.invoke.*;
import java.lang.reflect.Field;

public final class ReferenceFactory
{
	private static final MethodType STATIC_CONSTRUCTOR_TYPE   = MethodType.methodType(void.class, Field.class);
	private static final MethodType INSTANCE_CONSTRUCTOR_TYPE = MethodType
		                                                            .methodType(void.class, Object.class, long.class);

	private static Field getField(Class<?> type, String fieldName) throws NoSuchFieldException
	{
		return type.getDeclaredField(fieldName);
	}

	public static long getObjectFieldOffset(Class<?> type, String fieldName)
	{
		try
		{
			return ReflectUtils.UNSAFE.objectFieldOffset(type.getDeclaredField(fieldName));
		}
		catch (NoSuchFieldException ex)
		{
			throw new RuntimeException(ex);
		}
	}

	// Bootstrap Factories

	public static CallSite instanceRefMetafactory(MethodHandles.Lookup caller, String fieldName, MethodType methodType)
		throws Throwable
	{
		final Class<?> enclosingClass = methodType.parameterType(0);
		final Class<?> targetType = methodType.returnType();
		// The field to reference and its offset
		final Field field = getField(enclosingClass, fieldName);
		final long offset = ReflectUtils.UNSAFE.objectFieldOffset(field);
		// The Unsafe*Ref constructor
		final MethodHandle constructor = caller.findConstructor(targetType, INSTANCE_CONSTRUCTOR_TYPE);
		// Insert the offset argument, returning a method of type (enclosingClass)Unsafe*Ref
		return new ConstantCallSite(MethodHandles.insertArguments(constructor, 1, offset).asType(methodType));
	}

	public static CallSite staticRefMetafactory(MethodHandles.Lookup caller, String fieldName, MethodType methodType,
		                                           Class<?> enclosingClass) throws Throwable
	{
		final Class<?> targetType = methodType.returnType();
		// The field to reference
		final Field field = getField(enclosingClass, fieldName);
		// The Unsafe*Ref(Field) constructor
		final MethodHandle constructor = caller.findConstructor(targetType, STATIC_CONSTRUCTOR_TYPE);
		// The resulting Unsafe*Ref
		final Object result = constructor.invoke(field);
		return new ConstantCallSite(MethodHandles.constant(targetType, result));
	}

	public static CallSite propertyRefMetafactory(MethodHandles.Lookup caller,
		                                             @SuppressWarnings("UnusedParameters") String invokedName,
		                                             MethodType invokedType, MethodHandle getter, MethodHandle setter)
		throws Exception
	{
		final PropertyReferenceMetafactory prm = new PropertyReferenceMetafactory(caller, invokedType, getter, setter);
		return prm.buildCallSite();
	}

	// -------------------------
	// GEN_NOTICE
	// Timestamp: TIME_STAMP
	// -------------------------

#import Base.dgs
#foreach PRIMITIVE_SPECS

	// TYPE_NAME

	public static TYPE_NAME##Ref new##TYPE_NAME##Ref(Object base, long offset)
	{
		return new Unsafe##TYPE_NAME##Ref(base, offset);
	}

	public static TYPE_NAME##Ref new##TYPE_NAME##Ref(Object base, Class<?> type, String fieldName) throws NoSuchFieldException
	{
		return new Unsafe##TYPE_NAME##Ref(base, getField(type, fieldName));
	}

	public static TYPE_NAME##Ref newStatic##TYPE_NAME##Ref(Class<?> type, String fieldName) throws NoSuchFieldException
	{
		return new Unsafe##TYPE_NAME##Ref(getField(type, fieldName));
	}

	public static TYPE_NAME##Ref new##TYPE_NAME##ArrayRef(PRIMITIVE[] array, int index)
	{
		return new TYPE_NAME##ArrayRef(array, index);
	}
#endfor

	// -------------------------
	// END OF GENERATED CODE
	// -------------------------
}
