# suppress inspection "UnusedProperty" for whole file

# General

member.named=%1$s '%2$s'
member.class=class
member.field=field
member.method=method
member.constructor=constructor
member.initializer=initializer
member.classparameter=class parameter
member.variable=variable
member.typeargument=type argument
member.property=property
member.property.setter=property setter
member.property.getter=property getter

# Resolution

resolve.any='%s' could not be resolved to a type, method or field
resolve.package='%s' could not be resolved to a package or class
resolve.header='%s' could not be resolved to a header file
resolve.type='%s' could not be resolved to a type
resolve.type.package='%1$s' could not be resolved to a type in '%2$s'
resolve.field='%s' could not be resolved to a field
resolve.label='%s' could not be resolved to a label

# Headers

package.missing=Missing Package Declaration
package.invalid=Invalid Package Declaration in package '%s'
package.default=Invalid Package Declaration in default package

import.invalid=Invalid Import Declaration
import.wildcard.invalid=Wildcard Imports cannot be used on classes in Import Declarations, use a Using Declaration instead
using.invalid=Invalid Using Declaration
using.wildcard.invalid=Wildcard Imports cannot be used on packages in Using Declarations, use an Import Declaration instead
using.class.invalid=Using Declarations cannot point to classes, use an Import Declaration instead

include.unit=The Dyvil Unit '%s' cannot be included because it does not have a Header Declaration
include.internal=The internal header '%s' cannot be included because it is private to it's library
include.invisible=The header '%s' cannot be included because it is not visible

header.name.mismatch=Invalid Header Declaration - Mismatching Names
header.name=Header Name: %s
header.declaration.name=Header Declaration Name: %s

typealias.invalid=Invalid Type Alias - Type expected

# Types

typeparameter.bound.class=Type Parameters can only have one bound that is a class
typeparameter.declaration=Type Parameter: %s

type.array.void=Array Types cannot wrap the type 'void'
type.class.generic=Generic Types cannot be used at this location
type.class.lambda=Lambda Types cannot be used at this location
type.class.typevar=Type Variable Types cannot be used at this location
type.super.array=Array Types cannot be used as super types
type.super.typevar=Type Variable Types cannot be used as super types
type.wildcard.invalid=Wildcard Types cannot be used at this location
type.lambda.return=Invalid Lambda Type - Missing Return Type
type.annotated.invalid=Invalid Annotated Type - Type expected
type.generic.class_not_generic=The non-generic class '%s' cannot be parameterized
type.dimensions=Type Dimensions: %d
type.expected=Expected Type: %s
type.enclosing=Enclosing Type: %s
type.auto.deprecated=The type name 'auto' is deprecated. For local variables, use the 'var' keyword instead.

type.access.invisible=The type '%s' cannot be accessed because it is not visible
type.access.internal=The internal class '%s' cannot be accessed because it is private to it's library
type.access.invalid=The instance of the type '%s' cannot be accessed because it is not an object type

# Annotations

annotation.type=The type '%s' is not an annotation type
annotation.type.invalid=Invalid Annotation - Missing Annotation Type
annotation.target=The annotation type '%s' is not applicable for the target
annotation.target.element=Element Target Type: %s
annotation.target.allowed=Allowed Target Types: %s
annotation.method='%2$s' could not be resolved to an annotation interface method for '%1$s'
annotation.constant=The value for '%s' has to be a constant expression
annotation.parameter.missing=The annotation of type '%1$s' does not provide a value for the non-default parameter '%2$s'
annotation.parameter.type=The value for '%s' is incompatible with the required type
annotation.array.not_constant=The array element cannot be converted to a compile-time constant
annotation.field.not_constant=The field '%1$s' cannot be folded to a compile-time constant

# -- Classes --

class.extend.type=The %1$s '%2$s' cannot be extended, only classes are allowed
class.extend.final=The final class '%s' cannot be extended
class.extend.internal=The internal class '%s' cannot be extended
class.implement.type=The %1$s '%2$s' cannot be implemented, only interfaces are allowed
class.implement.internal=The internal interface '%s' cannot be extended
class.object.constructor=The object class '%s' cannot have a constructor
class.method.abstract=The type '%1$s' doesn't override the abstract method '%2$s' of the super type '%3$s'
class.method.conflict=Conflicting interface method '%1$s' in direct super-interfaces of class '%2$s', override this method

class.object.field=The object class '%s' cannot declare a field named 'instance'
class.null.field=The class '%s' with the 'null' modifier cannot declared a field named 'NULL'
class.nil.field=The class '%s' with the 'nil' modifier cannot declared a field named 'NIL'

trait.field.warning=The field '%s' is implicitly public, static and final in a trait

interface.property.initializer=Properties in Interfaces cannot declare Property Initializers
interface.member.public=The member '%s' does not need to be declared 'public' in an interface
interface.classparameters=Interfaces and Traits cannot declare Class Parameters
interface.constructor=Interfaces and Traits cannot declare Constructors
interface.initializer=Interfaces cannot declare Initializers

interface.functional.not_found=The functional interface '%s' does not have an abstract method
interface.functional.multiple=The functional interface '%s' has multiple abstract methods
interface.functional.class=The FunctionalInterface annotation can only be applied to interfaces and traits

# Class Parameters

classparameter.type=Class Parameter Type: %s
classparameter.type.incompatible=The default value of the class parameter '%s' is incompatible with the parameter type
classparameter.type.infer=The type of the class parameter '%s' could not be inferred
classparameter.type.void=Class Parameters cannot have the type void

classparameter.access.instance=The class parameter '%s' cannot be accessed from a static context
classparameter.access.unqualified=The class parameter '%s' should be qualified with 'this'
classparameter.assign.final=The final class parameter '%s' cannot be assigned
classparameter.assign.type=The type of the assigned value is incompatible with the type of the class parameter '%s'
classparameter.assign.annotation=The annotation parameter '%s' cannot be assigned

# -- Members --

# Modifiers

modifiers.illegal=The %1$s has illegal modifiers: %2$s
modifiers.static.unimplemented=The %1$s is declared static, but does not have an implementation
modifiers.static.abstract=The %1$s cannot be declared both static and abstract
modifiers.native.implemented=The %1$s cannot be declared native if it has an implementation
modifiers.native.abstract=The %1$s cannot be declared both native and abstract
modifiers.abstract.implemented=The %1$s cannot be declared abstract if it has an implementation
modifiers.abstract.concrete_class=The %1$s cannot be declared abstract as a member of the concrete type %2$s
modifiers.unimplemented=The %1$s is not implemented, but does not have an abstract modifier

# Access

access.invisible=The %s cannot be accessed because it is not visible
access.internal=The internal %s cannot be accessed because it is private to it's library

# Initializers

initializer.type=The block of an Initializer has to be usable as a statement

initializercall.invalid=Initializer Calls can only appear as the first statement of a constructor

# Constructors

constructor.invalid=Invalid Constructor
constructor.abstract=The constructor does not have an implementation
constructor.type=The constructor must not return a result
constructor.static=Constructors cannot be declared static
constructor.typevar.infer=The type argument for the type variable '%2$s' of the class '%1$s' was inferred to %3$s
constructor.typevar.incompatible=The type argument for the type variable '%2$s' of the class '%1$s' is incompatible with \
  it's bounds
constructor.return=Constructors cannot return a value

constructor.access.resolve=The constructor for '%s' could not be resolved
constructor.access.ambiguous=Ambiguous call to constructor of class '%s'
constructor.access.abstract=The abstract class '%s' cannot be instantiated
constructor.access.interface=The interface '%s' cannot be instantiated
constructor.access.internal=The internal constructor for '%s' cannot be accessed because it is private to it's library
constructor.access.array.length=The number of array length parameters exceeds the type dimensions
constructor.access.array.count=Number of Length Parameters: %d
constructor.access.array.type=The array length parameter has to be of type int
constructor.access.array.typevar=Cannot create an array of the generic type parameter %s

# -- Methods --

method.duplicate=Duplicate method '%1$s' with erased signature '%2$s'
method.type=Method Return Type: %s
method.type.incompatible=The return value of the method '%s' is incompatible with the return type
method.type.infer=The type of the method '%s' could not be inferred
method.type.abstract=The type of the abstract method '%s' could not be inferred
method.exception.type=The thrown exception must be a subtype of java.lang.Throwable
method.receivertype.incompatible=The receiver type of the method '%s' is incompatible with the enclosing class

method.receivertype=Receiver Type: %s
method.classtype=Class Type: %s

method.override.notfound=The method '%s' must override or implement a supertype method
method.overrides=The method '%s' overrides a method, but does not have an 'override' modifier
method.override.final=The method '%s' cannot override a final method
method.override.private=The method '%s' cannot override a private method
method.override.protected=The method '%s' cannot reduce the visibility of the overridden protected method
method.override.public=The method '%s' cannot reduce the visibility of the overridden public method
method.override=Overriden Method: %s from class %s
method.override.type=Overriden Return Type: %s
method.override.type.incompatible=The return type of the method '%s' is incompatible with the overridden method type

method.typevar.infer=The type argument for the type variable '%2$s' of the method '%1$s' was inferred to %3$s
method.typevar.incompatible=The type argument for the type variable '%2$s' of the method '%1$s' is incompatible with \
  it's bounds

method.access.static=The static method '%s' should be accessed in a static way
method.access.static.type=The static method '%1$s' of type '%2$s' should be accessed from that type
method.access.instance=The instance method '%s' cannot be accessed from a static context
method.access.unqualified=The instance method '%s' should be qualified with 'this'
method.access.infix_type=The infix method argument for '%s' is incompatible with the required type
method.access.receiver_type=The receiver for the instance method '%s' is incompatible with the required receiver type
method.access.prefix_type=The prefix method argument for '%s' is incompatible with the required type
method.access.argument_type=The method argument for '%s' is incompatible with the required type
method.access.resolve='%s' could not be resolved to a method
method.access.resolve.field='%s' could not be resolved to a method or field
method.access.ambiguous=Ambigous call to method '%s'

method.access.argument_types=Argument Types: %s
method.access.candidates=Candidates:

# Parameters

parameter.type=Parameter Type: %s
parameter.type.incompatible=The default value of the parameter '%s' is incompatible with the parameter type
parameter.type.infer=The type of the parameter '%s' could not be inferred
parameter.type.void=Parameters cannot have the type void

parameter.assign.final=The final parameter '%s' cannot be assigned
parameter.assign.type=The type of the assigned value is incompatible with the type of the parameter '%s'

arguments.duplicate.key=Duplicate Named Parameter '%s'

# Generics

generic.count=Invalid number of generic type arguments
generic.type=Generic Type Argument: %s
generic.type.incompatible=The generic type argument is incompatible with the type variable '%1$s' (in class %2$s)

# Properties

property.initializer.type=The initializer of a Property has to be usable as a statement
property.type.infer=The type of the property '%s' could not be inferred
property.empty=The property '%s' cannot have neither a getter nor a setter
property.type.void=The property '%s' cannot have the type 'void'

# Fields

field.type=Field Type: %s
field.type.incompatible=The initial value of the field '%s' is incompatible with the field type
field.type.infer=The type of the field '%s' could not be inferred
field.type.infer.novalue=The type of the uninitialized field '%s' could not be inferred
field.type.void=Fields cannot have the type void
field.property.setter.final=The final field '%s' cannot define a default property setter

field.access.invisible=The field '%s' cannot be accessed because it is not visible
field.access.internal=The internal field '%s' cannot be accessed because it is private to it's library
field.access.instance=The instance field '%s' cannot be accessed from a static context
field.access.static=The static field '%s' should be accessed in a static way
field.access.static.type=The static field '%1$s' of type '%2$s' should be accessed from that type
field.access.receiver_type=The receiver for the instance field '%s' incompatible with the required receiver type
field.access.unqualified=The instance field '%s' should be qualified with 'this'
field.assign.type=The type of the assigned value is incompatible with the type of the field '%s'
field.assign.final=The final field '%s' cannot be assigned

# Variables

variable.type=Variable Type: %s
variable.value=The variable '%s' has to be declared with an initial value
variable.shadow=The variable '%s' shadows another variable with the same name declared earlier
variable.type.incompatible=The initial value of the variable '%s' is incompatible with the variable type
variable.type.infer=The type of the variable '%s' could not be inferred
variable.type.void=Variables cannot have the type void
variable.assign.type=The type of the assigned value is incompatible with the type of the variable '%s'
variable.assign.final=The final variable '%s' cannot be assigned

variable.access.capture=The parameter '%s' cannot be accessed in this context because it is neither final nor \
  effectively final and cannot be converted to a Reference Variable
variable.assign.capture=The parameter '%s' cannot be assigned as it cannot be converted to a Reference Variable

# References

reference.expression.invalid=The expression cannot be referenced
reference.parameter.capture=The parameter '%s' cannot be converted to a reference
reference.field.final=The final field '%s' cannot be converted to a reference
reference.property.no_setter=The property '%s' cannot be converted to a reference because it doesn't have a setter

# Deprecation

deprecated.since=Deprecated Since: %s
deprecated.reason=Reason: %s
deprecated.reasons=Reasons: %s
deprecated.description=Description: %s
deprecated.replacements=Replacements: %s

experimental.stage=Stage: %s
experimental.description=Description: %s

# Expressions

value.type=Value Type: %s
expression.type=Expression Type: %s
receiver.type=Receiver Type: %s

operator.declaration=Operator Declaration: %s
operator.unresolved='%s' could not be resolved to an operator
operator.invalid_position=The %2$s operator '%s' should not be used in %3$s position
operator.infix_none=The infix operator '%s' without associativity cannot be used in this position

this.assign=Cannot assign a value to 'this'
this.access.static='this' cannot be accessed in a static context
this.instance=No enclosing instance for '%s' available

super.assign=Cannot assign a value to 'super'
super.access.static='super' cannot be accessed in a static context
super.access.type='super' cannot be accessed: The enclosing type does not have a super type
super.type.invalid=The requested super type is not a super type of the enclosing type
super.type.indirect=The requested super type is not a direct super type of the enclosing type
super.type.requested=Requested Super Type: %s

cast.type.invalid=Invalid Cast - Type expected
cast.value.invalid=Invalid Cast - Expression expected
cast.unnecessary=Unnecessary Cast: The value is already of the casted type
cast.incompatible=Invalid Cast: The expression of type %1$s cannot be casted to %2$s because %1$s is neither a super-type nor a sub-type of %2$s

instanceof.type.invalid=Invalid Instance Check - Type expected
instanceof.value.invalid=Invalid Instance Check - Expression expected
instanceof.value.primitive=Instance checks cannot be performed on primitive expressions
instanceof.type.primitive=Instance checks cannot be performed with primitive types
instanceof.type.equal=Unnecessary instance check: The expression is already of type %1$s
instanceof.type.subtype=Unnecessary instance check: The expression of type %1$s can only be of type %2$s because %1$s is a sub-type of %2$s
instanceof.type.incompatible=Invalid instance check: The expression of type %1$s can never be of type %2$s because %1$s is neither a super-type nor a sub-type of %2$s

array.void=Cannot create an array with element type 'void'
array.element.type.expected=Expected Element Type: %s
array.element.type.actual=Actual Element Type: %s
array.element.type.incompatible=The array element type is incompatible with the array type

map.key.type.expected=Expected Key Type: %s
map.key.type.actual=Actual Key Type: %s
map.key.type.incompatible=The key type is incompatible with the required key type
map.value.type.expected=Expected Key Type: %s
map.value.type.actual=Actual Key Type: %s
map.value.type.incompatible=The value type is incompatible with the required value type

tuple.element.type.expected=Expected Tuple Element Type: %s
tuple.element.type.actual=Actual Tuple Element Type: %s
tuple.element.type.incompatible=The tuple type is incompatible with the required tuple type
tuple.method=The literal conversion from (%1$s) to %2$s cannot be performed as %2$s does not have a static apply(%1$s) method

lambda.parameter.type=The type of the Lambda Parameter '%s' could not be inferred
lambda.parameter.implicit=The type of the implicit Lambda Parameter could not be inferred
lambda.method=The Lambda Expression could not be linked to a functional method
lambda.value.type.incompatible=The Lambda Return Value is incompatible with it's Return Type
lambda.value.invalid=Invalid Lambda Expression - Missing return value
lambda.return_type.incompatible=The explicit Lambda Return Type is incompatible with the actual return type
lambda.return_type=Lambda Return Type: %s


nil.type=The Nil Literal cannot be used in this context because the expected type '%1$s' does not have an \
  'NilConvertible' annotation.
nil.untyped=The Nil Literal cannot be used in a context where no type is expected
nil.method=The Nil Conversion to %1$s cannot be performed because '%1$s' does not have a static %2$s() method

wildcard.type=The Wildcard Literal cannot be used where no type is expected

string.interpolation.void=The String Interpolation argument cannot be of type void
string.concat.void=Expressions of type void cannot be part of String Concatenation Chains

colon_operator.left.type=The left value of the colon operator is incompatible with the expected type
colon_operator.left.invalid=Invalid Colon Operator - Missing left value
colon_operator.right.type=The right value of the colon operator is incompatible with the expected type
colon_operator.right.invalid=Invalid Colon Operator - Missing right value

classoperator.invalid=Invalid Class Operator - Type expected
typeoperator.invalid=Invalid Type Operator - Type expected
nullcheck.primitive=Cannot perform a Null Pointer Check on a primitive value
varargs.invalid=The Varargs Expansion Operator can only be used in place of Varargs Parameters

range.type=Range Type: %s
range.start.type=The type of the range start is incompatible with the required type
range.end.type=The type of the range end is incompatible with the required type
range.element.type.incompatible=The element type of the range operator cannot be used for ranges, only numeric types \
  and subtypes of dyvil.collection.range.Rangeable are allowed
range.element.type=Range Element Type: %s

# Patterns

case.invalid=Invalid Case Statement - Invalid Expression
match.invalid=Invalid Match Expression - Expression expected
match.condition.type=The condition of a Case Condition has to evaluate to a boolean value
match.value.type.incompatible=The type of the match case is incompatible with the return type of the match expression

pattern.type=Pattern Type: %s
pattern.type.incompatible=The type of the pattern is incompatible with the matched value type
pattern.dead=Unreachable Pattern
pattern.object=The class '%s' cannot be used as an Object Class Pattern
pattern.class.count=The Case Class Pattern for '%s' has an invalid number of patterns
pattern.class.count.class=Class Parameter Count: %s
pattern.class.count.pattern=Pattern Count: %s
pattern.class.access=The parameter '%s' cannot be extracted because it is not visible and no getter method is available
pattern.class.access.type=Case Class Type: %s
pattern.class.type=The pattern for the parameter '%1$s' is incompatible with the parameter type
pattern.tuple.element.type=The tuple pattern type is incompatible with the required tuple type
pattern.typecheck.invalid=Invalid Type Check pattern - Type expected

# Statements

if.condition.type=The Condition of an If Statement has to evaluate to a boolean value
if.condition.invalid=Invalid If Statement - Missing Condition
if.then.type=The type of the then branch is incompatible with the required type
if.else.type=The type of the else branch is incompatible with the required type

while.action.type=The action of a While Statement has to be usable as a statement
while.condition.type=The condition of While Statement has to evaluate to a boolean value
while.condition.invalid=Invalid While Statement - Missing Condition

repeat.action.type=The action of a Repeat Statement has to be usable as a statement
repeat.condition.type=The condition of a Repeat Statement has to evaluate to a boolean value

# For Statements

for.condition.type=The condition of a For Statement has to evaluate to a boolean value
for.update.type=The update of a For Statement has to be usable as a statement
for.action.type=The action of a For Statement has to be usable as a statement

for.each.type=The iterated value of the For Each Statement is incompatible with the required type
for.each.invalid=Invalid For Each Statement - The expression cannot be iterated
for.variable.infer=The type of the loop variable '%s' could not be inferred
for.iterable.type=The element type of the Iterable is incompatible with the variable type
for.iterator.type=The element type of the Iterator is incompatible with the variable type
for.array.type=The element type of the iterated array is incompatible with the variable type
for.string.type=The type of the variable has to be 'char' when iterating over a String
for.range.type=The type of the iterated range is incompatible with the variable type

iterable.type=Iterable Type: %s
iterator.type=Iterator Type: %s

# Try / Catch Blocks

try.action.type.incompatible=The return type of the Try Block is incompatible with the required type
try.catch.type.not_throwable=The type of the Catch Block Variable must be a subtype of java.lang.Throwable
try.catch.type.incompatible=The return type of the Catch Block is incompatible with the required type
try.finally.type=The Finally Block of a Try Statement has to be usable as a statement

# Control Flow Statements

break.invalid=Invalid break Statement: break cannot be applied in the current context
break.invalid.type=Invalid break Statement: The statement labeled '%s' is not a loop
continue.invalid=Invalid continue Statement: continue cannot be applied in the current context
continue.invalid.type=Invalid continue Statement: The statement labeled '%s' is not a loop
goto.invalid=Invalid goto Statement: goto cannot be applied in the current context
goto.warning=goto should not be used

return.void.invalid=Cannot return from a method with a return type other than 'void'
return.type.incompatible=The expression cannot be returned because it is incompatible with the return type of this context
return.type=Return Type: %s

# Misc.

value.constant=The expression could not be converted to a compile-time constant
value.constant.depth=Max. Constant Folding Depth: %d

literal.method=The literal conversion from %1$s to %2$s cannot be performed as %2$s does not have a static apply%3$s method
literal.type.incompatible=The type of the literal conversion is incompatible with the required type
literal.type.conversion=Conversion Type: %s
literal.type.method=Conversion Method:\n\t\t%s

braceaccess.invalid=Invalid Brace Access - No implicit value in scope

throw.type=The value of the throw statement must be a subtype of java.lang.Throwable
statementlist.statement=A statement in a statement list has to be usable as such
statementlist.return=The return value of the statement list has to be usable as a statement
statementlist.declaration.invalid=The %s cannot be declared in this context

# Exceptions

exception.unhandled=Unhandled Exception type '%s'
exception.type=Exception Type: %s
